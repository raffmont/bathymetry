#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tiny FastAPI tile server for the Bathymetry demo.

Serves:
- /tiles/vector/{z}/{x}/{y}.pbf        -> Vector MBTiles (MVT)
- /tiles/bathy/{z}/{x}/{y}.png         -> Bathy raster MBTiles (PNG8) [optional]
- /tiles/hillshade/{z}/{x}/{y}.png     -> Hillshade raster MBTiles (PNG8) [optional]
- /tiles/slope/{z}/{x}/{y}.png         -> Slope raster MBTiles (PNG8) [optional]
- /tilejson/{name}                     -> TileJSON files generated by obfuscate_bathy_tiles.py (static JSON)

Environment variables (optional):
- BATHY_VECTOR_MBTILES    (default: ./out/bathy_contours.mbtiles)
- BATHY_RASTER_MBTILES    (default: ./out/bathy_raster.mbtiles)
- BATHY_HILLSHADE_MBTILES (default: ./out/bathy_hillshade.mbtiles)
- BATHY_SLOPE_MBTILES     (default: ./out/bathy_slope.mbtiles)
- TILEJSON_DIR            (default: ./out/tilejson)
- HOST (default: 127.0.0.1) and PORT (default: 8080) are used by uvicorn when running directly

Notes:
- MBTiles store tiles with TMS Y. Incoming URL is XYZ Y, so we convert.
- This server intentionally stays minimal. For production, add caching headers, gzip for pbf, CORS rules, etc.
"""

from __future__ import annotations

import gzip
import os
import sqlite3
from functools import lru_cache
from pathlib import Path
from typing import Optional

from fastapi import FastAPI, HTTPException, Response
from fastapi.middleware.cors import CORSMiddleware

APP = FastAPI(title="Bathymetry MBTiles Server", version="0.1.0")

# Enable CORS so demos opened from file:// or another origin can fetch tiles easily.
APP.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["GET"],
    allow_headers=["*"],
)

def _tms_y(z: int, y_xyz: int) -> int:
    return (2 ** z - 1) - y_xyz

def _mbtiles_path(env_key: str, default_path: str) -> Path:
    return Path(os.environ.get(env_key, default_path)).expanduser().resolve()

VECTOR_MBTILES = _mbtiles_path("BATHY_VECTOR_MBTILES", "./out/bathy_contours.mbtiles")
BATHY_MBTILES  = _mbtiles_path("BATHY_RASTER_MBTILES", "./out/bathy_raster.mbtiles")
HS_MBTILES     = _mbtiles_path("BATHY_HILLSHADE_MBTILES", "./out/bathy_hillshade.mbtiles")
SLOPE_MBTILES  = _mbtiles_path("BATHY_SLOPE_MBTILES", "./out/bathy_slope.mbtiles")
TILEJSON_DIR   = Path(os.environ.get("TILEJSON_DIR", "./out/tilejson")).expanduser().resolve()

@lru_cache(maxsize=8)
def _conn(path: str) -> sqlite3.Connection:
    con = sqlite3.connect(path, check_same_thread=False)
    con.row_factory = sqlite3.Row
    return con

def _fetch_tile(mbtiles: Path, z: int, x: int, y_xyz: int) -> Optional[bytes]:
    if not mbtiles.exists():
        return None
    con = _conn(str(mbtiles))
    y = _tms_y(z, y_xyz)
    row = con.execute(
        "SELECT tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?",
        (z, x, y),
    ).fetchone()
    return row["tile_data"] if row else None

def _pbf_response(data: bytes) -> Response:
    # Many tile servers gzip-compress MVT; browsers support it.
    gz = gzip.compress(data, compresslevel=6)
    return Response(
        content=gz,
        media_type="application/x-protobuf",
        headers={
            "Content-Encoding": "gzip",
            "Cache-Control": "public, max-age=3600",
        },
    )

def _png_response(data: bytes) -> Response:
    return Response(
        content=data,
        media_type="image/png",
        headers={"Cache-Control": "public, max-age=3600"},
    )

@APP.get("/health")
def health():
    return {
        "vector_mbtiles": str(VECTOR_MBTILES),
        "bathy_mbtiles": str(BATHY_MBTILES),
        "hillshade_mbtiles": str(HS_MBTILES),
        "slope_mbtiles": str(SLOPE_MBTILES),
        "tilejson_dir": str(TILEJSON_DIR),
        "vector_exists": VECTOR_MBTILES.exists(),
        "bathy_exists": BATHY_MBTILES.exists(),
        "hillshade_exists": HS_MBTILES.exists(),
        "slope_exists": SLOPE_MBTILES.exists(),
        "tilejson_exists": TILEJSON_DIR.exists(),
    }

@APP.get("/tiles/vector/{z}/{x}/{y}.pbf")
def vector_tile(z: int, x: int, y: int):
    blob = _fetch_tile(VECTOR_MBTILES, z, x, y)
    if blob is None:
        raise HTTPException(status_code=404, detail="Vector tile not found (MBTiles missing or empty).")
    return _pbf_response(blob)

@APP.get("/tiles/bathy/{z}/{x}/{y}.png")
def bathy_tile(z: int, x: int, y: int):
    blob = _fetch_tile(BATHY_MBTILES, z, x, y)
    if blob is None:
        raise HTTPException(status_code=404, detail="Bathy raster tile not found (MBTiles missing or empty).")
    return _png_response(blob)

@APP.get("/tiles/hillshade/{z}/{x}/{y}.png")
def hillshade_tile(z: int, x: int, y: int):
    blob = _fetch_tile(HS_MBTILES, z, x, y)
    if blob is None:
        raise HTTPException(status_code=404, detail="Hillshade tile not found (MBTiles missing or empty).")
    return _png_response(blob)

@APP.get("/tiles/slope/{z}/{x}/{y}.png")
def slope_tile(z: int, x: int, y: int):
    blob = _fetch_tile(SLOPE_MBTILES, z, x, y)
    if blob is None:
        raise HTTPException(status_code=404, detail="Slope tile not found (MBTiles missing or empty).")
    return _png_response(blob)

@APP.get("/tilejson/{name}")
def tilejson(name: str):
    # name can be e.g. "bathy_contours.tilejson"
    p = (TILEJSON_DIR / name).resolve()
    if not str(p).startswith(str(TILEJSON_DIR)):
        raise HTTPException(status_code=400, detail="Invalid name")
    if not p.exists():
        raise HTTPException(status_code=404, detail="TileJSON not found")
    return Response(content=p.read_bytes(), media_type="application/json", headers={"Cache-Control": "no-cache"})

if __name__ == "__main__":
    import uvicorn
    host = os.environ.get("HOST", "127.0.0.1")
    port = int(os.environ.get("PORT", "8080"))
    uvicorn.run("server:APP", host=host, port=port, reload=True)
